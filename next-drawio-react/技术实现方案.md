# Next-DrawIO Pro 技术实现方案

## 1. 技术架构概览

### 1.1 整体架构
```
├── Frontend (Next.js 16 + React 19)
│   ├── 组件层 (UI Components)
│   ├── 状态管理 (Zustand)
│   ├── 画布引擎 (Fabric.js)
│   └── 工具系统 (Tool Manager)
├── 数据层
│   ├── 本地存储 (IndexedDB)
│   ├── 文件管理 (File System API)
│   └── 云端存储 (可选)
└── 工具链
    ├── TypeScript
    ├── Tailwind CSS
    ├── ESLint + Prettier
    └── Vite (构建工具)
```

### 1.2 核心技术选型理由

**Next.js 16 + React 19**
- ✅ 最新 React 特性支持 (并发渲染、服务器组件)
- ✅ 优秀的开发体验和性能
- ✅ 内置优化和最佳实践
- ✅ 良好的 SEO 支持

**Fabric.js**
- ✅ 强大的 Canvas 操作能力
- ✅ 丰富的图形对象支持
- ✅ 内置事件系统和交互
- ✅ 良好的扩展性

**Zustand**
- ✅ 轻量级状态管理
- ✅ TypeScript 友好
- ✅ 简单易用的 API
- ✅ 良好的性能

## 2. 项目结构设计

```
next-drawio/
├── src/
│   ├── app/                    # Next.js App Router
│   │   ├── layout.tsx
│   │   ├── page.tsx
│   │   └── globals.css
│   ├── components/             # React 组件
│   │   ├── ui/                # 基础 UI 组件
│   │   ├── canvas/            # 画布相关组件
│   │   ├── toolbar/           # 工具栏组件
│   │   ├── panels/            # 面板组件
│   │   └── modals/            # 模态框组件
│   ├── hooks/                 # 自定义 Hooks
│   ├── store/                 # 状态管理
│   ├── types/                 # TypeScript 类型定义
│   ├── utils/                 # 工具函数
│   ├── constants/             # 常量定义
│   └── styles/                # 样式文件
├── public/
├── docs/
└── tests/
```

## 3. 核心模块设计

### 3.1 框架无关的画布核心引擎

#### 3.1.1 独立绘图引擎设计

为了实现跨框架兼容性，我们将绘图核心引擎设计为独立的 TypeScript 库：

```typescript
// packages/core/src/engine/CanvasEngine.ts
export class CanvasEngine {
  private canvas: HTMLCanvasElement;
  private context: CanvasRenderingContext2D;
  private objects: CanvasObject[] = [];
  private viewport: Viewport;
  private eventEmitter: EventEmitter;

  constructor(options: CanvasEngineOptions) {
    this.setupCanvas(options.canvasElement);
    this.setupEventHandling();
  }

  // 核心 API - 框架无关
  addObject(object: CanvasObjectData): string {
    const canvasObject = this.createCanvasObject(object);
    this.objects.push(canvasObject);
    this.render();
    this.emit('object:added', canvasObject);
    return canvasObject.id;
  }

  removeObject(id: string): boolean {
    const index = this.objects.findIndex(obj => obj.id === id);
    if (index !== -1) {
      const removed = this.objects.splice(index, 1)[0];
      this.render();
      this.emit('object:removed', removed);
      return true;
    }
    return false;
  }

  updateObject(id: string, updates: Partial<CanvasObjectData>): boolean {
    const object = this.objects.find(obj => obj.id === id);
    if (object) {
      Object.assign(object, updates);
      this.render();
      this.emit('object:updated', object);
      return true;
    }
    return false;
  }

  // 事件系统 - 供框架集成使用
  on(event: string, handler: EventHandler): void {
    this.eventEmitter.on(event, handler);
  }

  off(event: string, handler: EventHandler): void {
    this.eventEmitter.off(event, handler);
  }

  private emit(event: string, data?: any): void {
    this.eventEmitter.emit(event, data);
  }
}
```

#### 3.1.2 通用数据模型

```typescript
// packages/core/src/types/index.ts
export interface CanvasObject {
  id: string;
  type: ObjectType;
  transform: Transform;
  geometry: Geometry;
  style: Style;
  data: Record<string, any>;
  metadata: ObjectMetadata;
}

export interface Transform {
  position: Point;
  rotation: number;
  scale: Point;
  skew: Point;
}

export interface Geometry {
  // 基础图形
  x: number;
  y: number;
  width: number;
  height: number;
  
  // 路径相关
  path?: PathData;
  
  // 文字相关
  text?: string;
  fontSize?: number;
  fontFamily?: string;
  
  // 高级图形
  points?: Point[];
  radius?: number;
  sides?: number;
}

export interface Style {
  fill?: FillStyle;
  stroke?: StrokeStyle;
  opacity?: number;
  blendMode?: BlendMode;
  filter?: FilterStyle;
  shadow?: ShadowStyle;
}

// 框架适配器接口
export interface FrameworkAdapter {
  // 渲染方法
  render(object: CanvasObject, context: RenderContext): void;
  
  // 事件处理
  handleMouseEvent(event: MouseEvent, context: InteractionContext): boolean;
  handleKeyboardEvent(event: KeyboardEvent, context: InteractionContext): boolean;
  
  // 生命周期
  onMount?(context: ComponentContext): void;
  onUnmount?(): void;
  onUpdate?(prevProps: any, nextProps: any): void;
}
```

#### 3.1.3 React 适配器实现

```typescript
// packages/react/src/ReactAdapter.ts
export class ReactAdapter implements FrameworkAdapter {
  private engine: CanvasEngine;
  private containerRef: RefObject<HTMLDivElement>;

  constructor(engine: CanvasEngine, containerRef: RefObject<HTMLDivElement>) {
    this.engine = engine;
    this.containerRef = containerRef;
  }

  render(object: CanvasObject, context: RenderContext): void {
    // React 特定的渲染逻辑
    const reactElement = this.createObjectComponent(object);
    
    // 使用 React 渲染到容器
    const root = createRoot(this.containerRef.current!);
    root.render(reactElement);
  }

  private createObjectComponent(object: CanvasObject): ReactElement {
    switch (object.type) {
      case 'rectangle':
        return <RectangleComponent object={object} />;
      case 'circle':
        return <CircleComponent object={object} />;
      case 'text':
        return <TextComponent object={object} />;
      default:
        return <div>Unknown object type</div>;
    }
  }
}

// packages/react/src/CanvasProvider.tsx
export const CanvasProvider: React.FC<CanvasProviderProps> = ({
  children,
  engineOptions
}) => {
  const engineRef = useRef<CanvasEngine>();
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (containerRef.current) {
      engineRef.current = new CanvasEngine({
        canvasElement: containerRef.current,
        ...engineOptions
      });
    }

    return () => {
      engineRef.current?.destroy();
    };
  }, []);

  const contextValue = useMemo(() => ({
    engine: engineRef.current,
    container: containerRef.current
  }), []);

  return (
    <CanvasContext.Provider value={contextValue}>
      <div ref={containerRef} className="canvas-container">
        {children}
      </div>
    </CanvasContext.Provider>
  );
};
```

#### 3.1.4 Vue 适配器实现

```typescript
// packages/vue/src/VueAdapter.ts
export class VueAdapter implements FrameworkAdapter {
  private engine: CanvasEngine;
  private container: Ref<HTMLElement>;

  constructor(engine: CanvasEngine, container: Ref<HTMLElement>) {
    this.engine = engine;
    this.container = container;
  }

  render(object: CanvasObject, context: RenderContext): void {
    // Vue 特定的渲染逻辑
    const app = createApp({
      render() {
        return this.createObjectComponent(object);
      },
      methods: {
        createObjectComponent(object: CanvasObject) {
          switch (object.type) {
            case 'rectangle':
              return h(RectangleComponent, { object });
            case 'circle':
              return h(CircleComponent, { object });
            case 'text':
              return h(TextComponent, { object });
            default:
              return h('div', 'Unknown object type');
          }
        }
      }
    });

    app.mount(this.container.value!);
  }
}

// packages/vue/src/CanvasComponent.vue
<template>
  <div ref="canvasContainer" class="canvas-container">
    <slot></slot>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue';
import { CanvasEngine } from '@vector-draw/core';
import { VueAdapter } from './VueAdapter';

const canvasContainer = ref<HTMLElement>();
let engine: CanvasEngine;
let adapter: VueAdapter;

onMounted(() => {
  if (canvasContainer.value) {
    engine = new CanvasEngine({
      canvasElement: canvasContainer.value
    });
    adapter = new VueAdapter(engine, canvasContainer);
  }
});

onUnmounted(() => {
  engine?.destroy();
});

// 暴露给子组件使用
provide('canvasEngine', engine);
provide('canvasAdapter', adapter);
</script>
```

#### 3.1.5 Angular 适配器实现

```typescript
// packages/angular/src/CanvasAdapter.ts
@Injectable()
export class CanvasAdapter implements FrameworkAdapter {
  private engine: CanvasEngine;
  private elementRef: ElementRef;

  constructor(
    @Inject(PLATFORM_ID) private platformId: Object,
    private elementRef: ElementRef
  ) {}

  ngOnInit() {
    if (isPlatformBrowser(this.platformId)) {
      this.engine = new CanvasEngine({
        canvasElement: this.elementRef.nativeElement
      });
    }
  }

  ngOnDestroy() {
    this.engine?.destroy();
  }

  render(object: CanvasObject, context: RenderContext): void {
    // Angular 特定的渲染逻辑
    const componentFactory = this.componentFactoryResolver.resolveComponentFactory(
      this.getObjectComponentType(object.type)
    );
    
    const componentRef = this.viewContainerRef.createComponent(componentFactory);
    componentRef.instance.object = object;
    componentRef.changeDetectorRef.detectChanges();
  }
}

// packages/angular/src/canvas.component.ts
@Component({
  selector: 'vdp-canvas',
  template: `
    <div class="canvas-container" #canvasContainer>
      <ng-content></ng-content>
    </div>
  `,
  providers: [CanvasAdapter]
})
export class CanvasComponent implements OnInit, OnDestroy {
  @ViewChild('canvasContainer', { static: true }) canvasContainer!: ElementRef;

  constructor(private adapter: CanvasAdapter) {}

  ngOnInit() {
    this.adapter.initialize(this.canvasContainer.nativeElement);
  }

  ngOnDestroy() {
    this.adapter.destroy();
  }
}
```

### 3.2 插件化架构

```typescript
// packages/core/src/plugins/PluginSystem.ts
export class PluginSystem {
  private plugins: Map<string, Plugin> = new Map();
  private hooks: Map<string, Hook[]> = new Map();

  registerPlugin(plugin: Plugin): void {
    if (this.plugins.has(plugin.name)) {
      throw new Error(`Plugin ${plugin.name} already registered`);
    }

    this.plugins.set(plugin.name, plugin);
    
    // 注册插件的钩子
    plugin.hooks?.forEach(hook => {
      this.registerHook(hook.event, hook.handler);
    });
  }

  unregisterPlugin(name: string): void {
    const plugin = this.plugins.get(name);
    if (plugin) {
      // 移除插件的钩子
      plugin.hooks?.forEach(hook => {
        this.unregisterHook(hook.event, hook.handler);
      });
      
      this.plugins.delete(name);
    }
  }

  executeHook(event: string, data: any): any {
    const hooks = this.hooks.get(event) || [];
    let result = data;

    for (const hook of hooks) {
      result = hook(result);
    }

    return result;
  }
}

// 插件接口
export interface Plugin {
  name: string;
  version: string;
  description?: string;
  dependencies?: string[];
  
  // 插件生命周期
  install?(engine: CanvasEngine): void;
  uninstall?(engine: CanvasEngine): void;
  
  // 钩子系统
  hooks?: PluginHook[];
  
  // 扩展功能
  tools?: Tool[];
  commands?: Command[];
  panels?: PanelDefinition[];
}

// 示例插件：高级绘图工具
export class AdvancedToolsPlugin implements Plugin {
  name = 'advanced-tools';
  version = '1.0.0';
  description = 'Advanced drawing tools plugin';

  tools = [
    new BezierPenTool(),
    new GradientFillTool(),
    new PathSimplificationTool()
  ];

  install(engine: CanvasEngine): void {
    // 注册工具到引擎
    this.tools.forEach(tool => {
      engine.registerTool(tool);
    });
  }

  uninstall(engine: CanvasEngine): void {
    // 移除工具
    this.tools.forEach(tool => {
      engine.unregisterTool(tool.id);
    });
  }
}
```

### 3.2 工具系统

```typescript
// src/types/tools.ts
export interface Tool {
  id: string;
  name: string;
  icon: string;
  cursor: string;
  onMouseDown: (event: CanvasEvent) => void;
  onMouseMove: (event: CanvasEvent) => void;
  onMouseUp: (event: CanvasEvent) => void;
}

// src/store/toolStore.ts
interface ToolState {
  activeTool: string;
  toolSettings: Record<string, any>;
  
  setTool: (toolId: string) => void;
  updateSettings: (settings: any) => void;
}

// src/tools/RectangleTool.ts
export class RectangleTool implements Tool {
  id = 'rectangle';
  name = '矩形工具';
  icon = '/icons/rectangle.svg';
  cursor = 'crosshair';
  
  onMouseDown(event: CanvasEvent) {
    // 开始绘制矩形
  }
  
  onMouseMove(event: CanvasEvent) {
    // 更新矩形大小
  }
  
  onMouseUp(event: CanvasEvent) {
    // 完成矩形绘制
  }
}
```

### 3.3 属性面板系统

```typescript
// src/components/panels/PropertiesPanel.tsx
interface PropertiesPanelProps {
  selectedObjects: CanvasObject[];
  onUpdateObject: (id: string, updates: Partial<CanvasObject>) => void;
}

// 针对不同对象类型的属性编辑器
export const RectangleProperties = ({ object, onUpdate }: Props) => (
  <div>
    <NumberInput 
      label="宽度" 
      value={object.size.width}
      onChange={(width) => onUpdate(object.id, { size: { ...object.size, width } })}
    />
    <NumberInput 
      label="高度" 
      value={object.size.height}
      onChange={(height) => onUpdate(object.id, { size: { ...object.size, height } })}
    />
  </div>
);
```

## 4. 状态管理架构

### 4.1 Zustand Store 结构

```typescript
// src/store/index.ts
export const useAppStore = create<AppState>((set, get) => ({
  // 画布状态
  canvas: {
    objects: [],
    selectedObjects: [],
    zoom: 1,
    pan: { x: 0, y: 0 },
    viewport: { width: 800, height: 600 }
  },
  
  // 工具状态
  tools: {
    activeTool: 'select',
    settings: {}
  },
  
  // 历史状态
  history: {
    past: [],
    present: null,
    future: []
  },
  
  // UI 状态
  ui: {
    showGrid: true,
    showRulers: true,
    theme: 'light',
    panels: {
      properties: true,
      layers: true,
      tools: true
    }
  }
}));
```

### 4.2 中间件系统

```typescript
// src/store/middleware/history.ts
export const historyMiddleware = (config: StateCreator<AppState>) => (
  set: SetState<AppState>,
  get: GetState<AppState>
) => {
  return config(
    (args) => {
      const previousState = get();
      set(args);
      
      // 记录历史操作
      const currentState = get();
      if (shouldRecordHistory(previousState, currentState)) {
        addToHistory(previousState, currentState);
      }
    },
    get
  );
};
```

## 5. 文件管理系统

### 5.1 文件格式支持

```typescript
// src/utils/fileManager.ts
export class FileManager {
  // 导入 SVG
  async importSVG(file: File): Promise<CanvasObject[]> {
    const text = await file.text();
    const parser = new DOMParser();
    const doc = parser.parseFromString(text, 'image/svg+xml');
    return this.parseSVGToObjects(doc);
  }
  
  // 导出 SVG
  exportSVG(objects: CanvasObject[]): string {
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    objects.forEach(obj => {
      svg.appendChild(this.objectToSVGElement(obj));
    });
    return new XMLSerializer().serializeToString(svg);
  }
  
  // 导出 PNG
  async exportPNG(canvas: HTMLCanvasElement): Promise<Blob> {
    return new Promise((resolve) => {
      canvas.toBlob(resolve!, 'image/png');
    });
  }
}
```

### 5.2 本地存储

```typescript
// src/utils/localStorage.ts
export class LocalStorage {
  private dbName = 'Next-DrawIODB';
  private version = 1;
  
  async saveProject(project: Project): Promise<void> {
    const db = await this.openDB();
    const tx = db.transaction(['projects'], 'readwrite');
    await tx.objectStore('projects').put(project);
  }
  
  async loadProject(id: string): Promise<Project | null> {
    const db = await this.openDB();
    const tx = db.transaction(['projects'], 'readonly');
    return await tx.objectStore('projects').get(id);
  }
}
```

## 6. 性能优化策略

### 6.1 渲染优化

```typescript
// src/hooks/useCanvasOptimization.ts
export const useCanvasOptimization = () => {
  // 视口裁剪
  const getVisibleObjects = useCallback((objects: CanvasObject[], viewport: Viewport) => {
    return objects.filter(obj => isInViewport(obj, viewport));
  }, []);
  
  // 对象池复用
  const objectPool = useRef(new Map());
  
  // 批量更新
  const batchUpdate = useCallback((updates: ObjectUpdate[]) => {
    requestAnimationFrame(() => {
      updates.forEach(update => applyUpdate(update));
    });
  }, []);
};
```

### 6.2 内存管理

```typescript
// src/utils/memoryManager.ts
export class MemoryManager {
  private maxObjects = 10000;
  private gcThreshold = 0.8;
  
  shouldGC(): boolean {
    return performance.memory?.usedJSHeapSize! / performance.memory?.jsHeapSizeLimit! > this.gcThreshold;
  }
  
  garbageCollect(): void {
    // 清理未使用的对象
    // 压缩历史记录
    // 释放临时数据
  }
}
```

## 7. 开发工作流

### 7.1 开发环境配置

```json
// package.json scripts
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint src --ext .ts,.tsx",
    "lint:fix": "eslint src --ext .ts,.tsx --fix",
    "type-check": "tsc --noEmit",
    "test": "jest",
    "test:watch": "jest --watch"
  }
}
```

### 7.2 代码质量工具

```javascript
// eslint.config.js
module.exports = {
  extends: [
    'next/core-web-vitals',
    '@typescript-eslint/recommended',
    'prettier'
  ],
  rules: {
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/explicit-function-return-type': 'warn',
    'prefer-const': 'error',
    'no-var': 'error'
  }
};
```

## 8. 测试策略

### 8.1 单元测试

```typescript
// src/tests/canvas.test.ts
describe('Canvas Operations', () => {
  test('should add rectangle to canvas', () => {
    const { result } = renderHook(() => useAppStore());
    
    act(() => {
      result.current.canvas.addObject({
        id: 'rect-1',
        type: 'rectangle',
        position: { x: 10, y: 10 },
        size: { width: 100, height: 50 },
        style: { fill: 'red' }
      });
    });
    
    expect(result.current.canvas.objects).toHaveLength(1);
    expect(result.current.canvas.objects[0].type).toBe('rectangle');
  });
});
```

### 8.2 集成测试

```typescript
// src/tests/integration.test.ts
describe('File Operations', () => {
  test('should export and import SVG correctly', async () => {
    const objects = [
      { id: 'rect-1', type: 'rectangle', /* ... */ }
    ];
    
    const svgData = exportSVG(objects);
    const importedObjects = await importSVG(new File([svgData], 'test.svg'));
    
    expect(importedObjects).toHaveLength(1);
    expect(importedObjects[0].type).toBe('rectangle');
  });
});
```

## 9. 部署和发布

### 9.1 构建优化

```javascript
// next.config.ts
const nextConfig = {
  experimental: {
    optimizePackageImports: ['fabric', 'zustand']
  },
  webpack: (config) => {
    config.optimization.splitChunks = {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all'
        },
        fabric: {
          test: /[\\/]node_modules[\\/]fabric[\\/]/,
          name: 'fabric',
          chunks: 'all'
        }
      }
    };
    return config;
  }
};
```

### 9.2 性能监控

```typescript
// src/utils/performance.ts
export const performanceMonitor = {
  measureCanvasRender: (fn: () => void) => {
    const start = performance.now();
    fn();
    const end = performance.now();
    
    if (end - start > 16.67) { // 超过 60fps
      console.warn(`Canvas render took ${end - start}ms`);
    }
  }
};
```

---

这个技术实现方案为 Next-DrawIO Pro 提供了完整的技术架构和实施路径。接下来可以按照这个方案开始具体的代码实现工作。